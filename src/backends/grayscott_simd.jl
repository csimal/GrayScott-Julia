# NOTE: The following code was partially generated by Claude 3.5 Opus
"""
    SIMDGrayScott{N} <: AbstractGrayScott

An optimized backend for the Gray-Scott equations using explicit SIMD.
"""
struct SIMDGrayScott{N} <: AbstractGrayScott end

# Constructor that chooses an appropriate SIMD width based on the system
function SIMDGrayScott()
    if SIMD.VecWidth{Float64}() == 8
        SIMDGrayScott{8}()  # AVX-512
    elseif SIMD.VecWidth{Float64}() == 4
        SIMDGrayScott{4}()  # AVX2
    elseif SIMD.VecWidth{Float64}() == 2
        SIMDGrayScott{2}()  # SSE2
    else
        SIMDGrayScott{1}()  # Fallback to scalar operations
    end
end

function output!(out, state, ::SIMDGrayScott{N}) where {N}
    @assert size(state, 1) == size(out, 1) + 2
    @assert size(state, 2) == size(out, 2) + 2
    @assert size(out,1) % N == 0
    lane = VecRange{N}(0)
    for j in axes(out, 2)
        @inbounds for i in 1:N:size(out,2)
            # the indexing calls below explicitly use SIMD vectors
            out[i+lane,j,1] = state[i+1+lane,j+1,1]
            out[i+lane,j,2] = state[i+1+lane,j+1,2]
        end
    end
end

function reaction!(du, dv, u, v, params::GrayScottParams, ::SIMDGrayScott{N}) where {N}
    height, width = size(u)
    T = eltype(du)
    Vec = SIMD.Vec{W, T}
    f, k = params.f, params.k
    for j in 2:width-1, i in 2:W:height-1
        u_vec = Vec(u, i, j)
        v_vec = Vec(v, i, j)
        du_vec = Vec(du, i, j)
        dv_vec = Vec(dv, i, j)

        uv = u_vec * v_vec * v_vec
        du_vec += -uv + f * (T(1.0) - u_vec)
        dv_vec += uv - (f + k) * v_vec

        vstore(du_vec, du, i, j)
        vstore(dv_vec, dv, i, j)
    end
end


function laplacian!(du, u, D, ::SIMDGrayScott{N}) where {N}
    height, width = size(u)
    T = eltype(du)
    Vec = SIMD.Vec{N, T}

    for j in 2:width-1, i in 2:N:height-1
        u_center = Vec(u, i, j)
        u_left = Vec(u, i-1, j)
        u_right = Vec(u, i+1, j)
        u_up = Vec(u, i, j-1)
        u_down = Vec(u, i, j+1)
        u_upleft = Vec(u, i-1, j-1)
        u_upright = Vec(u, i+1, j-1)
        u_downleft = Vec(u, i-1, j+1)
        u_downright = Vec(u, i+1, j+1)

        tmp = T(0.25) * (u_upleft + u_upright + u_downleft + u_downright) +
              T(0.5)  * (u_up + u_left + u_right + u_down) -
              T(3.0)  * u_center

        vstore(tmp * D, du, i, j)
    end
end
